name: Aider Auto-fix issues and PR comments via external prompt

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created]

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    if: |
      (
        github.event_name == 'issues' &&
        (github.event.action == 'opened' || github.event.action == 'edited')
      ) || (
        github.event_name == 'issue_comment' &&
        github.event.issue.pull_request &&
        contains(github.event.comment.body, '/aider') &&
        !contains(github.event.comment.user.login, '[bot]')
      )
    permissions:
      contents: write
      pull-requests: write
      issues: write
    env:
      GEMINI_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git User
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Checkout PR Branch (if issue_comment)
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Issue comment trigger: Checking out PR branch..."
          PR_NUMBER=${{ github.event.issue.number }}
          PR_HEAD_REF=$(gh pr view $PR_NUMBER --json headRefName -q .headRefName --repo $GITHUB_REPOSITORY)
          if [[ -z "$PR_HEAD_REF" || "$PR_HEAD_REF" == "null" ]]; then
             echo "::error::Could not determine PR head branch for PR #$PR_NUMBER via gh CLI."
             exit 1
          fi
          echo "Checking out PR head branch: $PR_HEAD_REF for PR #$PR_NUMBER"
          git fetch origin "refs/heads/${PR_HEAD_REF}:refs/remotes/origin/${PR_HEAD_REF}" --no-tags
          git checkout "$PR_HEAD_REF"
          echo "Successfully checked out branch $(git rev-parse --abbrev-ref HEAD)"

      - name: Get Linked Issue Details (if issue_comment on PR)
        id: get_linked_issue
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "Checking for issues linked to PR #${PR_NUMBER}..."
          # Fetch the first node directly, jq will output null if it doesn't exist or the path is wrong
          LINKED_ISSUE_NODE_JSON=$(gh pr view $PR_NUMBER --json closingIssuesReferences --jq '.closingIssuesReferences.nodes[0]' --repo $GITHUB_REPOSITORY 2>/dev/null || echo "null")

          # Check if the fetched node is null, empty, or literally the string "null"
          if [[ -z "$LINKED_ISSUE_NODE_JSON" || "$LINKED_ISSUE_NODE_JSON" == "null" ]]; then
            echo "No linked issue found or failed to fetch node for PR #${PR_NUMBER}."
            echo "linked_issue_number=" >> $GITHUB_OUTPUT
            echo "linked_issue_title=" >> $GITHUB_OUTPUT
            echo "linked_issue_body=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Now try to extract the number from the potentially valid node JSON
          LINKED_ISSUE_NUMBER=$(echo "$LINKED_ISSUE_NODE_JSON" | jq -r '.number // empty')

          # Check if the number extraction failed
          if [[ -z "$LINKED_ISSUE_NUMBER" || "$LINKED_ISSUE_NUMBER" == "null" ]]; then
             echo "::warning::Found linked issue node reference but could not extract number from JSON: $LINKED_ISSUE_NODE_JSON"
             echo "linked_issue_number=" >> $GITHUB_OUTPUT
             echo "linked_issue_title=" >> $GITHUB_OUTPUT
             echo "linked_issue_body=" >> $GITHUB_OUTPUT
             exit 0
          fi

          echo "Found linked issue #${LINKED_ISSUE_NUMBER}. Fetching details..."
          ISSUE_DETAILS_JSON=$(gh issue view $LINKED_ISSUE_NUMBER --json title,body --repo $GITHUB_REPOSITORY)

          if [[ -z "$ISSUE_DETAILS_JSON" ]]; then
              echo "::warning::Could not fetch details for linked issue #${LINKED_ISSUE_NUMBER}."
              LINKED_ISSUE_TITLE="Error fetching title for #${LINKED_ISSUE_NUMBER}"
              LINKED_ISSUE_BODY="Error fetching body for #${LINKED_ISSUE_NUMBER}"
          else
              LINKED_ISSUE_TITLE=$(echo "$ISSUE_DETAILS_JSON" | jq -r '.title // empty')
              LINKED_ISSUE_BODY=$(echo "$ISSUE_DETAILS_JSON" | jq -r '.body // empty')
              echo "Fetched details for issue #${LINKED_ISSUE_NUMBER}."
          fi

          echo "linked_issue_number=$LINKED_ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "linked_issue_title<<EOF_LINKED_ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "$LINKED_ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "EOF_LINKED_ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "linked_issue_body<<EOF_LINKED_ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "$LINKED_ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF_LINKED_ISSUE_BODY" >> $GITHUB_OUTPUT

      - name: Fetch PR Details (Title, Body, SHAs, RefName)
        id: format_pr_details
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "::group::Fetch PR Details"
          set -e
          PR_DATA_JSON=$(gh pr view "$PR_NUMBER" --json baseRefOid,headRefOid,headRefName,title,body --repo "${GITHUB_REPOSITORY}" 2> pr_details_stderr.log || echo "FETCH_FAILED")
          if [[ "$PR_DATA_JSON" == "FETCH_FAILED" ]]; then
            echo "::error::Failed to fetch PR details."; cat pr_details_stderr.log >&2
            # Set default error values
            echo "PR_TITLE=Error fetching PR title" >> $GITHUB_ENV
            echo "PR_BODY=Error fetching PR body" >> $GITHUB_ENV
            echo "BASE_SHA=" >> $GITHUB_ENV
            echo "HEAD_SHA=" >> $GITHUB_ENV
            echo "HEAD_REF_NAME=" >> $GITHUB_ENV
          else
            PR_TITLE=$(echo "$PR_DATA_JSON" | jq -r .title)
            PR_BODY=$(echo "$PR_DATA_JSON" | jq -r .body)
            BASE_SHA=$(echo "$PR_DATA_JSON" | jq -r .baseRefOid)
            HEAD_SHA=$(echo "$PR_DATA_JSON" | jq -r .headRefOid)
            HEAD_REF_NAME=$(echo "$PR_DATA_JSON" | jq -r .headRefName)

            echo "PR_TITLE<<EOF_PR_TITLE" >> $GITHUB_ENV; echo "$PR_TITLE" >> $GITHUB_ENV; echo "EOF_PR_TITLE" >> $GITHUB_ENV
            echo "PR_BODY<<EOF_PR_BODY" >> $GITHUB_ENV; echo "$PR_BODY" >> $GITHUB_ENV; echo "EOF_PR_BODY" >> $GITHUB_ENV
            echo "BASE_SHA=$BASE_SHA" >> $GITHUB_ENV
            echo "HEAD_SHA=$HEAD_SHA" >> $GITHUB_ENV
            echo "HEAD_REF_NAME=$HEAD_REF_NAME" >> $GITHUB_ENV
            echo "Fetched PR Details: Title='${PR_TITLE:0:50}...', BaseSHA=$BASE_SHA, HeadSHA=$HEAD_SHA, RefName=$HEAD_REF_NAME"
          fi
          echo "::endgroup::"

      - name: Fetch Standard Comments (PR)
        id: format_fetch_comments
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "::group::Fetch Standard Comments (PR)"
          set -e
          COMMENTS_XML=""
          # Fetch comments associated with the PR's underlying issue number
          STD_COMMENTS_JSON=$(gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" --paginate 2> comments_stderr.log || echo "FETCH_FAILED")
          if [[ "$STD_COMMENTS_JSON" == "FETCH_FAILED" || -z "$STD_COMMENTS_JSON" ]]; then
              echo "::warning::Failed to fetch standard comments or received empty response."
              if [[ -s comments_stderr.log ]]; then cat comments_stderr.log; fi
          elif echo "$STD_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
              TSV_OUTPUT=$(echo "$STD_COMMENTS_JSON" | jq -r '.[] | select(.body != null) | [.user.login // "unknown", .created_at // "N/A", .body] | @tsv' 2> jq_std_error.log)
              JQ_EXIT_CODE=$?
              if [[ $JQ_EXIT_CODE -eq 0 && -n "$TSV_OUTPUT" ]]; then
                  while IFS=$'\t' read -r login created_at body; do
                      [[ -n "$login" || -n "$created_at" || -n "$body" ]] || continue
                      # Basic XML escaping for CDATA section content
                      body_escaped=$(echo "$body" | sed 's/]]>/]]\\&gt;/g')
                      COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$login</author><timestamp>$created_at</timestamp><content><![CDATA[${body_escaped}]]></content></comment>"
                  done <<< "$TSV_OUTPUT"
              elif [[ $JQ_EXIT_CODE -ne 0 ]]; then
                  echo "::warning::jq failed processing standard comments (exit code $JQ_EXIT_CODE). Error log:"; cat jq_std_error.log
              fi
          else
              echo "::warning::Fetched standard comments data is not a valid JSON array."
          fi
          echo "STANDARD_COMMENTS_XML<<EOF_COMMENTS_XML" >> $GITHUB_ENV; echo "$COMMENTS_XML" >> $GITHUB_ENV; echo "EOF_COMMENTS_XML" >> $GITHUB_ENV
          echo "Fetched ${#COMMENTS_XML} bytes of standard comment XML."
          echo "::endgroup::"

      - name: Fetch PR Review Comments & Bodies
        id: format_pr_reviews
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "::group::Fetch PR Review Comments & Bodies"
          set -e
          REVIEW_COMMENTS_XML=""
          # Fetch review comments specifically on the PR diff
          REVIEW_COMMENTS_JSON=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/comments" --paginate 2> rev_comments_stderr.log || echo "FETCH_FAILED")
          if [[ "$REVIEW_COMMENTS_JSON" != "FETCH_FAILED" && -n "$REVIEW_COMMENTS_JSON" ]] && echo "$REVIEW_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
            TSV_OUTPUT=$(echo "$REVIEW_COMMENTS_JSON" | jq -r '.[]|select(.body!=null)|[.user.login//"?",.created_at//"N/A",.body,.path//"?",.diff_hunk//"",(.line//.original_line//"N/A")]|@tsv' 2>jq_rev_com_err.log)
            if [[ $? -eq 0 && -n "$TSV_OUTPUT" ]]; then
              while IFS=$'\t' read -r u t b p h l; do
                [[ -n "$u"||-n "$t"||-n "$b" ]] || continue
                h_esc=$(echo "$h" | sed 's/]]>/]]\\&gt;/g'); b_esc=$(echo "$b" | sed 's/]]>/]]\\&gt;/g'); p_esc=$(echo "$p" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g; s/'"'"'/\&apos;/g') # XML escape path
                REVIEW_COMMENTS_XML="${REVIEW_COMMENTS_XML}<comment type=\"review_comment\" file=\"$p_esc\" line=\"$l\"><author>$u</author><timestamp>$t</timestamp><diff_hunk><![CDATA[$h_esc]]></diff_hunk><content><![CDATA[$b_esc]]></content></comment>"
              done <<< "$TSV_OUTPUT"
            elif [[ $? -ne 0 ]]; then echo "::warning::jq failed processing review comments. Error log:"; cat jq_rev_com_err.log; fi
          elif [[ "$REVIEW_COMMENTS_JSON" == "FETCH_FAILED" ]]; then echo "::warning::Failed to fetch review comments."; if [[ -s rev_comments_stderr.log ]]; then cat rev_comments_stderr.log; fi;
          fi

          # Fetch overall PR reviews (which might have bodies)
          REVIEWS_JSON=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/reviews" --paginate 2> reviews_stderr.log || echo "FETCH_FAILED")
          if [[ "$REVIEWS_JSON" != "FETCH_FAILED" && -n "$REVIEWS_JSON" ]] && echo "$REVIEWS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
            TSV_OUTPUT=$(echo "$REVIEWS_JSON" | jq -r '.[]|select(.body!=null and .body!="")|[.user.login//"?",.submitted_at//"N/A",.body,.state//"N/A"]|@tsv' 2>jq_rev_err.log)
            if [[ $? -eq 0 && -n "$TSV_OUTPUT" ]]; then
              while IFS=$'\t' read -r u t b s; do
                [[ -n "$u"||-n "$t"||-n "$b" ]] || continue
                b_esc=$(echo "$b" | sed 's/]]>/]]\\&gt;/g')
                REVIEW_COMMENTS_XML="${REVIEW_COMMENTS_XML}<comment type=\"review_body\" state=\"$s\"><author>$u</author><timestamp>$t</timestamp><content><![CDATA[$b_esc]]></content></comment>"
               done <<< "$TSV_OUTPUT"
            elif [[ $? -ne 0 ]]; then echo "::warning::jq failed processing reviews. Error log:"; cat jq_rev_err.log; fi
          elif [[ "$REVIEWS_JSON" == "FETCH_FAILED" ]]; then echo "::warning::Failed to fetch reviews."; if [[ -s reviews_stderr.log ]]; then cat reviews_stderr.log; fi;
          fi
          echo "REVIEW_COMMENTS_XML<<EOF_REVIEW_COMMENTS_XML" >> $GITHUB_ENV; echo "$REVIEW_COMMENTS_XML" >> $GITHUB_ENV; echo "EOF_REVIEW_COMMENTS_XML" >> $GITHUB_ENV
          echo "Fetched ${#REVIEW_COMMENTS_XML} bytes of review comment XML."
          echo "::endgroup::"

      - name: Fetch PR Diff
        id: format_pr_diff
        if: github.event_name == 'issue_comment'
        env:
          BASE_SHA: ${{ env.BASE_SHA }}
          HEAD_SHA: ${{ env.HEAD_SHA }}
        run: |
          echo "::group::Fetch PR Diff"
          PR_DIFF="<!-- Diff generation failed or skipped -->"
          if [[ -z "$BASE_SHA" || -z "$HEAD_SHA" || "$BASE_SHA" == "null" || "$HEAD_SHA" == "null" ]]; then
            echo "::warning::Cannot run git diff without valid base/head SHAs (Base: '$BASE_SHA', Head: '$HEAD_SHA')."
          else
            echo "Fetching diff between $BASE_SHA...$HEAD_SHA"
            # Fetching the diff without complex filtering for now
            set +e
            RAW_DIFF=$(git diff "${BASE_SHA}...${HEAD_SHA}")
            DIFF_EXIT_CODE=$?
            set -e
            if [[ $DIFF_EXIT_CODE -ne 0 ]]; then
              echo "::warning::git diff command failed with exit code $DIFF_EXIT_CODE."
              PR_DIFF="<!-- Error running git diff -->"
            elif [[ -z "$RAW_DIFF" ]]; then
              PR_DIFF="<!-- No changes detected in diff -->"
            else
              # Simple XML escaping for CDATA
              PR_DIFF=$(echo "$RAW_DIFF" | sed 's/]]>/]]\\&gt;/g')
            fi
          fi
          echo "PR_DIFF<<EOF_PR_DIFF" >> $GITHUB_ENV; echo "$PR_DIFF" >> $GITHUB_ENV; echo "EOF_PR_DIFF" >> $GITHUB_ENV
          echo "Fetched diff (approx size: ${#PR_DIFF} bytes)."
          echo "::endgroup::"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Aider and Dependencies
        run: |
          python -m pip install aider-install; aider-install
          pip install -U google-generativeai
          sudo apt-get update && sudo apt-get install -y jq

      - name: Determine Prompt for Aider
        id: determine_prompt
        shell: bash
        run: |
          PROMPT_FILE_PATH=".github/aider/issue-prompt.txt"
          mkdir -p .github/aider
          LINKED_ISSUE_TITLE="${{ steps.get_linked_issue.outputs.linked_issue_title }}"
          LINKED_ISSUE_BODY="${{ steps.get_linked_issue.outputs.linked_issue_body }}"
          LINKED_ISSUE_NUMBER="${{ steps.get_linked_issue.outputs.linked_issue_number }}"

          if [[ "${{ github.event_name }}" == "issues" ]]; then
            echo "Event Type: Issues. Using existing external API logic."
            ISSUE_TITLE_Q=$(printf '%q' "${{ github.event.issue.title }}")
            ISSUE_BODY_Q=$(printf '%q' "${{ github.event.issue.body }}")
            JSON_PAYLOAD=$(jq -n --arg title "$ISSUE_TITLE_Q" --arg body "$ISSUE_BODY_Q" '{"body":{"issue_title":$title,"issue_body":$body}}')
            API_RESULT=$(curl -s -w "\\n%{http_code}" \
              -X POST "https://app.windmill.dev/api/r/test1245/issue-trigger" \
              -H "Content-Type: application/json" --data-binary "$JSON_PAYLOAD" --max-time 90)
            HTTP_CODE=$(echo "$API_RESULT" | tail -n1); BODY=$(echo "$API_RESULT" | sed '$d'); echo "$BODY" > /tmp/api_response.txt
            if [[ "$HTTP_CODE" -eq 200 ]]; then PROMPT=$(jq -r '.processed_prompt // .effective_body // .message // empty' /tmp/api_response.txt); if [[ -z "$PROMPT" || "$PROMPT" == "null" ]]; then echo "::warning::API returned 200 but no prompt; falling back."; printf "Please fix the issue described below:\n\nTitle: %s\n\nBody:\n%s" "${{ github.event.issue.title }}" "${{ github.event.issue.body }}" > "$PROMPT_FILE_PATH"; else echo "$PROMPT" > "$PROMPT_FILE_PATH"; fi;
            else echo "::warning::API call failed (HTTP $HTTP_CODE). Falling back."; printf "Please fix the issue described below:\n\nTitle: %s\n\nBody:\n%s" "${{ github.event.issue.title }}" "${{ github.event.issue.body }}" > "$PROMPT_FILE_PATH"; fi
            rm -f /tmp/api_response.txt

          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            echo "Event Type: Issue Comment on PR #${{ github.event.issue.number }}. Assembling detailed prompt."

            # Fetch context from environment variables set by previous steps
            PR_NUMBER="${{ github.event.issue.number }}"
            PR_TITLE="${{ env.PR_TITLE }}"
            PR_BODY="${{ env.PR_BODY }}"
            STANDARD_COMMENTS_XML="${{ env.STANDARD_COMMENTS_XML }}"
            REVIEW_COMMENTS_XML="${{ env.REVIEW_COMMENTS_XML }}"
            PR_DIFF="${{ env.PR_DIFF }}"
            COMMENT_AUTHOR="${{ github.event.comment.user.login }}"
            COMMENT_TIMESTAMP="${{ github.event.comment.created_at }}"

            # Extract user's request from the triggering comment
            RAW_COMMENT_BODY="${{ github.event.comment.body }}"
            USER_COMMENT_REQUEST="${RAW_COMMENT_BODY#*/aider}"
            USER_COMMENT_REQUEST="${USER_COMMENT_REQUEST#"${USER_COMMENT_REQUEST%%[![:space:]]*}"}" # Trim leading whitespace
            USER_COMMENT_REQUEST="${USER_COMMENT_REQUEST%"${USER_COMMENT_REQUEST##*[![:space:]]}"}" # Trim trailing whitespace

            if [[ -z "$USER_COMMENT_REQUEST" ]]; then
              echo "::error::Comment with /aider provided, but no instruction found after it."
              printf "Error: /aider command found but no instruction followed." > "$PROMPT_FILE_PATH"
              exit 1
            fi

            # Escape user request for CDATA
            USER_COMMENT_REQUEST_ESCAPED=$(printf "%s" "$USER_COMMENT_REQUEST" | sed 's/]]>/]]\\&gt;/g') # Use printf for safe input to sed

            # Assemble the final prompt string
            FORMATTED_PROMPT="<github_context type=\"pr\" number=\"$PR_NUMBER\">"
            FORMATTED_PROMPT="${FORMATTED_PROMPT}<details><title><![CDATA[${PR_TITLE}]]></title><body><![CDATA[${PR_BODY}]]></body></details>"
            FORMATTED_PROMPT="${FORMATTED_PROMPT}<diff><![CDATA[${PR_DIFF}]]></diff>"
            FORMATTED_PROMPT="${FORMATTED_PROMPT}<comments>${STANDARD_COMMENTS_XML}${REVIEW_COMMENTS_XML}</comments>"

            # Add linked issue context if available
            if [[ -n "$LINKED_ISSUE_NUMBER" ]]; then
              LINKED_TITLE_ESCAPED=$(echo "$LINKED_ISSUE_TITLE" | sed 's/]]>/]]\\&gt;/g')
              LINKED_BODY_ESCAPED=$(echo "$LINKED_ISSUE_BODY" | sed 's/]]>/]]\\&gt;/g')
              FORMATTED_PROMPT="${FORMATTED_PROMPT}<linked_issue number=\"${LINKED_ISSUE_NUMBER}\"><title><![CDATA[${LINKED_TITLE_ESCAPED}]]></title><body><![CDATA[${LINKED_BODY_ESCAPED}]]></body></linked_issue>"
            fi

            FORMATTED_PROMPT="${FORMATTED_PROMPT}<user_request author=\"${COMMENT_AUTHOR}\" timestamp=\"${COMMENT_TIMESTAMP}\"><![CDATA[${USER_COMMENT_REQUEST_ESCAPED}]]></user_request>"
            FORMATTED_PROMPT="${FORMATTED_PROMPT}</github_context>"
            FORMATTED_PROMPT="${FORMATTED_PROMPT}<instructions><![CDATA[You are Aider, an AI Pair Programmer. You are reviewing a Pull Request. The user has provided a request in the <user_request> tag. Use the full context provided (PR details, diff, comments, linked issue) to understand the PR and the request. Apply the requested changes to the specified files.]]></instructions>"

            # echo "$FORMATTED_PROMPT" > "$PROMPT_FILE_PATH" # Unsafe expansion
            printf "%s" "$FORMATTED_PROMPT" > "$PROMPT_FILE_PATH" # Use printf for safe writing
            echo "Detailed prompt assembled and written to $PROMPT_FILE_PATH (Size: ${#FORMATTED_PROMPT} bytes)"

          else
            echo "::error::Unhandled event type: ${{ github.event_name }}"
            exit 1
          fi
          # Ensure output is set regardless of path
          echo "PROMPT_FILE_PATH=$PROMPT_FILE_PATH" >> $GITHUB_OUTPUT

      - name: Probe Chat for Relevant Files
        id: probe_files
        env:
          PROMPT_CONTENT_FILE: ${{ steps.determine_prompt.outputs.PROMPT_FILE_PATH }}
          # Pass key context for probe focus
          PR_TITLE: ${{ env.PR_TITLE }} # Available only on PR trigger
          LINKED_ISSUE_TITLE: ${{ steps.get_linked_issue.outputs.linked_issue_title }} # Available only on PR trigger if linked
          LINKED_ISSUE_NUMBER: ${{ steps.get_linked_issue.outputs.linked_issue_number }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          echo "Running probe-chat to find relevant files..."
          if [[ ! -f "$PROMPT_CONTENT_FILE" ]]; then
            echo "::error::Prompt file $PROMPT_CONTENT_FILE not found!"
            exit 1
          fi

          # Extract the core user request for probe-chat
          # For issues trigger, it's the whole file (or from API)
          # For PR comment trigger, extract from the structured prompt
          USER_REQUEST_FOR_PROBE=""
          if [[ "$EVENT_NAME" == "issues" ]]; then
              USER_REQUEST_FOR_PROBE=$(cat "$PROMPT_CONTENT_FILE")
          elif [[ "$EVENT_NAME" == "issue_comment" ]]; then
              # Attempt to extract content from <user_request> CDATA using basic tools
              USER_REQUEST_FOR_PROBE=$(sed -n 's/.*<user_request.*><!\[CDATA\[\(.*\)\]\]><\/user_request>.*/\1/p' "$PROMPT_CONTENT_FILE")
              if [[ -z "$USER_REQUEST_FOR_PROBE" ]]; then
                 echo "::warning::Could not extract user request from structured prompt for probe. Falling back to raw comment body."
                 # Fallback to raw comment body (might be less accurate)
                 RAW_COMMENT_BODY="${{ github.event.comment.body }}"
                 USER_REQUEST_FOR_PROBE="${RAW_COMMENT_BODY#*/aider}"
                 USER_REQUEST_FOR_PROBE="${USER_REQUEST_FOR_PROBE#"${USER_REQUEST_FOR_PROBE%%[![:space:]]*}"}"
                 USER_REQUEST_FOR_PROBE="${USER_REQUEST_FOR_PROBE%"${USER_REQUEST_FOR_PROBE##*[![:space:]]}"}"
              fi
          fi

          if [[ -z "$USER_REQUEST_FOR_PROBE" ]]; then
             echo "::error::Could not determine user request for probe!"
             exit 1
          fi

          # Prepare context for probe prompt
          CONTEXT_FOR_PROBE=""
          if [[ "$EVENT_NAME" == "issue_comment" ]]; then
             CONTEXT_FOR_PROBE="PR Title: $PR_TITLE\\n"
             if [[ -n "$LINKED_ISSUE_NUMBER" ]]; then
                CONTEXT_FOR_PROBE="${CONTEXT_FOR_PROBE}Linked Issue #$LINKED_ISSUE_NUMBER Title: $LINKED_ISSUE_TITLE\\n"
             fi
             CONTEXT_FOR_PROBE="${CONTEXT_FOR_PROBE}User Request: $USER_REQUEST_FOR_PROBE"
          else # Issues trigger
             CONTEXT_FOR_PROBE="Issue Context: $USER_REQUEST_FOR_PROBE" # User request here is the issue title/body/API result
          fi

          # Escape the context for JSON message
          MESSAGE_ESCAPED=$(jq -Rs . <<< "$CONTEXT_FOR_PROBE")

          # Construct the final message for probe-chat
          BASE_INSTRUCTION="Your job is ONLY to generate a list of files that need to be edited to implement the user's request."
          OUTPUT_INSTRUCTION="Output MUST be a single JSON array of file paths. Example: [\\\"src/main.rs\\\", \\\"lib/utils.ts\\\"]. DO NOT include explanations or any other text. Here is the user's request:"
          FINAL_MESSAGE_FOR_PROBE=$(printf "%s\\n%s\\nContext:\\n%s" "$BASE_INSTRUCTION" "$OUTPUT_INSTRUCTION" "$MESSAGE_ESCAPED")

          echo "Message being sent to probe-chat:"
          echo "$FINAL_MESSAGE_FOR_PROBE"

          set -o pipefail
          # Send the constructed message using --message argument
          PROBE_OUTPUT=$(npx --yes @buger/probe-chat@latest --model-name gemini-2.5-pro-preview-05-06 --message "$FINAL_MESSAGE_FOR_PROBE" 2>&1) || {
            echo "::error::probe-chat command failed. Output:"
            echo "$PROBE_OUTPUT"
            exit 1
          }
          set +o pipefail
          echo "Probe-chat raw output:"
          echo "$PROBE_OUTPUT"

          JSON_FILES=$(echo "$PROBE_OUTPUT" | sed -n '/^\s*\[/,$p' | sed '/^\s*\]/q')
          echo "Extracted JSON block:"
          echo "$JSON_FILES"

          FILES_LIST=$(echo "$JSON_FILES" | jq -e -r '[.[] | select(type == "string" and . != "" and . != null and (endswith("/") | not))] | map(@sh) | join(" ")' || echo "")

          if [[ -z "$FILES_LIST" ]]; then
             # Allow proceeding even if no files found, aider step will handle it
             echo "::warning::probe-chat did not identify any relevant files. Aider step might be skipped."
             FILES_LIST="" # Ensure it's empty
          fi

          echo "Formatted files list for aider: $FILES_LIST"
          echo "FILES_TO_EDIT=$FILES_LIST" >> $GITHUB_ENV

      - name: Run Aider with external prompt
        id: run_aider
        run: |
          echo "Files identified by probe-chat: ${{ env.FILES_TO_EDIT }}"
          # Check if FILES_TO_EDIT is empty (probe might have found none)
          if [[ -z "${{ env.FILES_TO_EDIT }}" ]]; then
            echo "::warning::Probe chat identified no relevant files. Skipping aider execution."
            echo "aider_output=Probe chat identified no relevant files to edit." >> $GITHUB_OUTPUT
            # Do not exit, let the workflow continue to report this
            exit 0
          fi

          # Aider will use the prompt file (.github/aider/issue-prompt.txt)
          # which now contains the full structured context for PR comments
          # or the API/issue context for issue triggers.
          aider \
            ${{ env.FILES_TO_EDIT }} \
            --model gemini/gemini-2.5-pro-preview-05-06 \
            --message-file .github/aider/issue-prompt.txt \
            --yes \
            --no-check-update \
            --auto-commits \
            --no-analytics \
            --no-stream | tee /tmp/aider_output.txt

          # AIDER_OUTPUT=$(cat /tmp/aider_output.txt) # Avoid intermediate variable
          echo "aider_output<<EOF" >> $GITHUB_OUTPUT
          cat /tmp/aider_output.txt >> $GITHUB_OUTPUT # Pipe directly
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Clean up prompt file
        if: always()
        run: rm -f .github/aider/issue-prompt.txt

      - name: Commit and Push Changes
        id: commit_and_push
        if: ${{ success() }}
        run: |
          if [[ "${{ github.event_name }}" == "issues" ]]; then
            BRANCH_NAME="aider-fix-issue-${{ github.event.issue.number }}"
            git checkout -b $BRANCH_NAME
            echo "Created branch $BRANCH_NAME for issue #${{ github.event.issue.number }}"
            git push origin $BRANCH_NAME
            echo "Pushed to new branch $BRANCH_NAME"
            echo "PR_BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "CHANGES_APPLIED_MESSAGE=Aider changes pushed to new branch $BRANCH_NAME." >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            CURRENT_BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
            echo "Attempting to push changes to PR branch $CURRENT_BRANCH_NAME for PR #${{ github.event.issue.number }}"
            if git push origin $CURRENT_BRANCH_NAME; then
              echo "Push to $CURRENT_BRANCH_NAME successful (or no new changes to push)."
              echo "CHANGES_APPLIED_MESSAGE=Aider changes (if any) pushed to PR branch $CURRENT_BRANCH_NAME." >> $GITHUB_OUTPUT
            else
              echo "::warning::Push to PR branch $CURRENT_BRANCH_NAME failed."
              echo "CHANGES_APPLIED_MESSAGE=Aider ran, but failed to push changes to PR branch $CURRENT_BRANCH_NAME." >> $GITHUB_OUTPUT
            fi
          fi

      - name: Create Pull Request
        if: success() && github.event_name == 'issues' && steps.commit_and_push.outputs.PR_BRANCH_NAME != '' && steps.commit_and_push.outputs.PR_BRANCH_NAME != null
        uses: peter-evans/create-pull-request@v6
        id: create_pr
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "[Aider PR] Add fixes for issue #${{ github.event.issue.number }}"
          branch: ${{ steps.commit_and_push.outputs.PR_BRANCH_NAME }}
          base: main
          delete-branch: true
          title: "[Aider] Fix for Issue #${{ github.event.issue.number }}: ${{ github.event.issue.title }}"
          body: |
            This PR was automatically generated by Aider based on issue #${{ github.event.issue.number }}.

            Linked to #${{ github.event.issue.number }}

            **Aider Output:**
            ```
            ${{ steps.run_aider.outputs.aider_output }}
            ```

      - name: Comment on issue
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          body: |
            âœ… Aider (via Gemini) has processed your request triggered by a `${{ github.event_name }}` event.

            ${{ steps.commit_and_push.outputs.CHANGES_APPLIED_MESSAGE || 'Aider processing complete.' }}

            ${{ github.event_name == 'issues' && steps.create_pr.outputs.pull-request-url && format('Pull Request created: {0}', steps.create_pr.outputs.pull-request-url) || '' }}${{ github.event_name == 'issues' && steps.commit_and_push.outputs.PR_BRANCH_NAME != '' && !steps.create_pr.outputs.pull-request-url && '*(PR creation may have been skipped or failed)*' || '' }}
            ${{ steps.run_aider.outputs.aider_output && steps.run_aider.outputs.aider_output != 'Probe chat identified no relevant files to edit.' && format('\\n**Aider Output:**\\n```\\n{0}\\n```', steps.run_aider.outputs.aider_output) || '' }}
