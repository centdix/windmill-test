name: Aider Auto-fix issues and PR comments via external prompt

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created]

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    if: |
      (
        github.event_name == 'issues' &&
        (github.event.action == 'opened' || github.event.action == 'edited')
      ) || (
        github.event_name == 'issue_comment' &&
        github.event.issue.pull_request &&
        contains(github.event.comment.body, '/aider') &&
        !contains(github.event.comment.user.login, '[bot]')
      )
    permissions:
      contents: write
      pull-requests: write
      issues: write
    env:
      GEMINI_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git User
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Checkout PR Branch (if issue_comment)
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Issue comment trigger: Checking out PR branch..."
          PR_NUMBER=${{ github.event.issue.number }}
          PR_HEAD_REF=$(gh pr view $PR_NUMBER --json headRefName -q .headRefName --repo $GITHUB_REPOSITORY)
          if [[ -z "$PR_HEAD_REF" || "$PR_HEAD_REF" == "null" ]]; then
             echo "::error::Could not determine PR head branch for PR #$PR_NUMBER via gh CLI."
             exit 1
          fi
          echo "Checking out PR head branch: $PR_HEAD_REF for PR #$PR_NUMBER"
          git fetch origin "refs/heads/${PR_HEAD_REF}:refs/remotes/origin/${PR_HEAD_REF}" --no-tags
          git checkout "$PR_HEAD_REF"
          echo "Successfully checked out branch $(git rev-parse --abbrev-ref HEAD)"

      - name: Get Linked Issue Details (if issue_comment on PR)
        id: get_linked_issue
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "Checking for issues linked to PR #${PR_NUMBER}..."
          # Fetch the first node directly, jq will output null if it doesn't exist or the path is wrong
          LINKED_ISSUE_NODE_JSON=$(gh pr view $PR_NUMBER --json closingIssuesReferences --jq '.closingIssuesReferences.nodes[0]' --repo $GITHUB_REPOSITORY 2>/dev/null || echo "null")

          # Check if the fetched node is null, empty, or literally the string "null"
          if [[ -z "$LINKED_ISSUE_NODE_JSON" || "$LINKED_ISSUE_NODE_JSON" == "null" ]]; then
            echo "No linked issue found or failed to fetch node for PR #${PR_NUMBER}."
            echo "linked_issue_number=" >> $GITHUB_OUTPUT
            echo "linked_issue_title=" >> $GITHUB_OUTPUT
            echo "linked_issue_body=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Now try to extract the number from the potentially valid node JSON
          LINKED_ISSUE_NUMBER=$(echo "$LINKED_ISSUE_NODE_JSON" | jq -r '.number // empty')

          # Check if the number extraction failed
          if [[ -z "$LINKED_ISSUE_NUMBER" || "$LINKED_ISSUE_NUMBER" == "null" ]]; then
             echo "::warning::Found linked issue node reference but could not extract number from JSON: $LINKED_ISSUE_NODE_JSON"
             echo "linked_issue_number=" >> $GITHUB_OUTPUT
             echo "linked_issue_title=" >> $GITHUB_OUTPUT
             echo "linked_issue_body=" >> $GITHUB_OUTPUT
             exit 0
          fi

          echo "Found linked issue #${LINKED_ISSUE_NUMBER}. Fetching details..."
          ISSUE_DETAILS_JSON=$(gh issue view $LINKED_ISSUE_NUMBER --json title,body --repo $GITHUB_REPOSITORY)

          if [[ -z "$ISSUE_DETAILS_JSON" ]]; then
              echo "::warning::Could not fetch details for linked issue #${LINKED_ISSUE_NUMBER}."
              LINKED_ISSUE_TITLE="Error fetching title for #${LINKED_ISSUE_NUMBER}"
              LINKED_ISSUE_BODY="Error fetching body for #${LINKED_ISSUE_NUMBER}"
          else
              LINKED_ISSUE_TITLE=$(echo "$ISSUE_DETAILS_JSON" | jq -r '.title // empty')
              LINKED_ISSUE_BODY=$(echo "$ISSUE_DETAILS_JSON" | jq -r '.body // empty')
              echo "Fetched details for issue #${LINKED_ISSUE_NUMBER}."
          fi

          echo "linked_issue_number=$LINKED_ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "linked_issue_title<<EOF_LINKED_ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "$LINKED_ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "EOF_LINKED_ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "linked_issue_body<<EOF_LINKED_ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "$LINKED_ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF_LINKED_ISSUE_BODY" >> $GITHUB_OUTPUT

      - name: Fetch PR Details (Title, Body, SHAs, RefName)
        id: format_pr_details
        if: env.FINAL_CONTEXT_TYPE == 'pr'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ env.ISSUE_OR_PR_NUMBER }}
        run: |
          echo "::group::Fetch PR Details (like probe-base)"
          set -e
          # Fetch SHAs and RefName first (mirroring probe-base)
          PR_REFS_JSON=$(gh pr view "$PR_NUMBER" --json baseRefOid,headRefOid,headRefName --repo "${GITHUB_REPOSITORY}" 2> pr_refs_stderr.log || echo "FETCH_FAILED")
          BASE_SHA=""; HEAD_SHA=""; HEAD_REF_NAME=""
          if [[ "$PR_REFS_JSON" == "FETCH_FAILED" ]]; then echo "::error::Failed to fetch PR SHAs/RefName."; cat pr_refs_stderr.log >&2; else
            BASE_SHA=$(echo "$PR_REFS_JSON" | jq -r .baseRefOid); HEAD_SHA=$(echo "$PR_REFS_JSON" | jq -r .headRefOid); HEAD_REF_NAME=$(echo "$PR_REFS_JSON" | jq -r .headRefName)
            if [[ -z "$BASE_SHA" || "$BASE_SHA" == "null" || -z "$HEAD_SHA" || "$HEAD_SHA" == "null" || -z "$HEAD_REF_NAME" || "$HEAD_REF_NAME" == "null" ]]; then
              echo "::error::Could not extract valid base SHA, head SHA, or head ref name from JSON: $PR_REFS_JSON"; BASE_SHA=""; HEAD_SHA=""; HEAD_REF_NAME=""
            else echo "Fetched SHAs/Ref: Base=$BASE_SHA, Head=$HEAD_SHA, Ref=$HEAD_REF_NAME"; fi
          fi
          echo "BASE_SHA=$BASE_SHA" >> $GITHUB_ENV; echo "HEAD_SHA=$HEAD_SHA" >> $GITHUB_ENV; echo "HEAD_REF_NAME=$HEAD_REF_NAME" >> $GITHUB_ENV

          # Fetch Title and Body separately (mirroring probe-base)
          PR_DATA_JSON=$(gh pr view "$PR_NUMBER" --json title,body --repo "${GITHUB_REPOSITORY}" 2> pr_details_stderr.log || echo 'FETCH_FAILED')
          PR_TITLE="Error fetching title"; PR_BODY="Error fetching body"
          if [[ "$PR_DATA_JSON" != "FETCH_FAILED" ]]; then
            PR_TITLE=$(echo "$PR_DATA_JSON" | jq -r '.title // "Error fetching title"'); PR_BODY=$(echo "$PR_DATA_JSON" | jq -r '.body // "Error fetching body"')
            echo "Fetched Title/Body: Title='${PR_TITLE:0:50}...'"
          else
             echo "::error::Failed to fetch PR title/body."; cat pr_details_stderr.log >&2 # Reuse stderr log
          fi
          echo "PR_TITLE<<EOF_PR_TITLE" >> $GITHUB_ENV; echo "$PR_TITLE" >> $GITHUB_ENV; echo "EOF_PR_TITLE" >> $GITHUB_ENV
          echo "PR_BODY<<EOF_PR_BODY" >> $GITHUB_ENV; echo "$PR_BODY" >> $GITHUB_ENV; echo "EOF_PR_BODY" >> $GITHUB_ENV

          echo "::endgroup::"

      - name: Fetch Standard Comments (PR)
        id: format_fetch_comments
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "::group::Fetch Standard Comments (PR)"
          set -e
          COMMENTS_XML=""
          # Fetch comments associated with the PR's underlying issue number
          STD_COMMENTS_JSON=$(gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" --paginate 2> comments_stderr.log || echo "FETCH_FAILED")
          if [[ "$STD_COMMENTS_JSON" == "FETCH_FAILED" || -z "$STD_COMMENTS_JSON" ]]; then
              echo "::warning::Failed to fetch standard comments or received empty response."
              if [[ -s comments_stderr.log ]]; then cat comments_stderr.log; fi
          elif echo "$STD_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
              TSV_OUTPUT=$(echo "$STD_COMMENTS_JSON" | jq -r '.[] | select(.body != null) | [.user.login // "unknown", .created_at // "N/A", .body] | @tsv' 2> jq_std_error.log)
              JQ_EXIT_CODE=$?
              if [[ $JQ_EXIT_CODE -eq 0 && -n "$TSV_OUTPUT" ]]; then
                  while IFS=$'\t' read -r login created_at body; do
                      [[ -n "$login" || -n "$created_at" || -n "$body" ]] || continue
                      # Basic XML escaping for CDATA section content
                      body_escaped=$(echo "$body" | sed 's/]]>/]]\\&gt;/g')
                      COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$login</author><timestamp>$created_at</timestamp><content><![CDATA[${body_escaped}]]></content></comment>"
                  done <<< "$TSV_OUTPUT"
              elif [[ $JQ_EXIT_CODE -ne 0 ]]; then
                  echo "::warning::jq failed processing standard comments (exit code $JQ_EXIT_CODE). Error log:"; cat jq_std_error.log
              fi
          else
              echo "::warning::Fetched standard comments data is not a valid JSON array."
          fi
          echo "STANDARD_COMMENTS_XML<<EOF_COMMENTS_XML" >> $GITHUB_ENV; echo "$COMMENTS_XML" >> $GITHUB_ENV; echo "EOF_COMMENTS_XML" >> $GITHUB_ENV
          echo "Fetched ${#COMMENTS_XML} bytes of standard comment XML."
          echo "::endgroup::"

      - name: Fetch PR Review Comments & Bodies
        id: format_pr_reviews
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "::group::Fetch PR Review Comments & Bodies"
          set -e
          REVIEW_COMMENTS_XML=""
          # Fetch review comments specifically on the PR diff
          REVIEW_COMMENTS_JSON=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/comments" --paginate 2> rev_comments_stderr.log || echo "FETCH_FAILED")
          if [[ "$REVIEW_COMMENTS_JSON" != "FETCH_FAILED" && -n "$REVIEW_COMMENTS_JSON" ]] && echo "$REVIEW_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
            TSV_OUTPUT=$(echo "$REVIEW_COMMENTS_JSON" | jq -r '.[]|select(.body!=null)|[.user.login//"?",.created_at//"N/A",.body,.path//"?",.diff_hunk//"",(.line//.original_line//"N/A")]|@tsv' 2>jq_rev_com_err.log)
            if [[ $? -eq 0 && -n "$TSV_OUTPUT" ]]; then
              while IFS=$'\t' read -r u t b p h l; do
                [[ -n "$u"||-n "$t"||-n "$b" ]] || continue
                h_esc=$(echo "$h" | sed 's/]]>/]]\\&gt;/g'); b_esc=$(echo "$b" | sed 's/]]>/]]\\&gt;/g'); p_esc=$(echo "$p" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g; s/'"'"'/\&apos;/g') # XML escape path
                REVIEW_COMMENTS_XML="${REVIEW_COMMENTS_XML}<comment type=\"review_comment\" file=\"$p_esc\" line=\"$l\"><author>$u</author><timestamp>$t</timestamp><diff_hunk><![CDATA[$h_esc]]></diff_hunk><content><![CDATA[$b_esc]]></content></comment>"
              done <<< "$TSV_OUTPUT"
            elif [[ $? -ne 0 ]]; then echo "::warning::jq failed processing review comments. Error log:"; cat jq_rev_com_err.log; fi
          elif [[ "$REVIEW_COMMENTS_JSON" == "FETCH_FAILED" ]]; then echo "::warning::Failed to fetch review comments."; if [[ -s rev_comments_stderr.log ]]; then cat rev_comments_stderr.log; fi;
          fi

          # Fetch overall PR reviews (which might have bodies)
          REVIEWS_JSON=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/reviews" --paginate 2> reviews_stderr.log || echo "FETCH_FAILED")
          if [[ "$REVIEWS_JSON" != "FETCH_FAILED" && -n "$REVIEWS_JSON" ]] && echo "$REVIEWS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
            TSV_OUTPUT=$(echo "$REVIEWS_JSON" | jq -r '.[]|select(.body!=null and .body!="")|[.user.login//"?",.submitted_at//"N/A",.body,.state//"N/A"]|@tsv' 2>jq_rev_err.log)
            if [[ $? -eq 0 && -n "$TSV_OUTPUT" ]]; then
              while IFS=$'\t' read -r u t b s; do
                [[ -n "$u"||-n "$t"||-n "$b" ]] || continue
                b_esc=$(echo "$b" | sed 's/]]>/]]\\&gt;/g')
                REVIEW_COMMENTS_XML="${REVIEW_COMMENTS_XML}<comment type=\"review_body\" state=\"$s\"><author>$u</author><timestamp>$t</timestamp><content><![CDATA[$b_esc]]></content></comment>"
               done <<< "$TSV_OUTPUT"
            elif [[ $? -ne 0 ]]; then echo "::warning::jq failed processing reviews. Error log:"; cat jq_rev_err.log; fi
          elif [[ "$REVIEWS_JSON" == "FETCH_FAILED" ]]; then echo "::warning::Failed to fetch reviews."; if [[ -s reviews_stderr.log ]]; then cat reviews_stderr.log; fi;
          fi
          echo "REVIEW_COMMENTS_XML<<EOF_REVIEW_COMMENTS_XML" >> $GITHUB_ENV; echo "$REVIEW_COMMENTS_XML" >> $GITHUB_ENV; echo "EOF_REVIEW_COMMENTS_XML" >> $GITHUB_ENV
          echo "Fetched ${#REVIEW_COMMENTS_XML} bytes of review comment XML."
          echo "::endgroup::"

      - name: Fetch Issue Details (Title, Body)
        id: format_issue_details
        if: env.FINAL_CONTEXT_TYPE == 'issue'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          ISSUE_NUMBER: ${{ env.ISSUE_OR_PR_NUMBER }}
        run: |
          echo "::group::Fetch Issue Details (Title, Body)"; set -e
          ISSUE_DATA_JSON=$(gh issue view "$ISSUE_NUMBER" --json title,body --repo "${GITHUB_REPOSITORY}" 2>/dev/null || echo 'FETCH_FAILED')
          ISSUE_TITLE="Error fetching title"; ISSUE_BODY="Error fetching body"
          if [[ "$ISSUE_DATA_JSON" != "FETCH_FAILED" && -n "$ISSUE_DATA_JSON" ]]; then
            ISSUE_TITLE=$(printf "%s" "$ISSUE_DATA_JSON" | jq -r '.title // "Error fetching title"')
            ISSUE_BODY=$(printf "%s" "$ISSUE_DATA_JSON" | jq -r '.body // "Error fetching body"')
          fi
          echo "ISSUE_TITLE<<EOF_ISSUE_TITLE" >> $GITHUB_ENV; echo "$ISSUE_TITLE" >> $GITHUB_ENV; echo "EOF_ISSUE_TITLE" >> $GITHUB_ENV
          echo "ISSUE_BODY<<EOF_ISSUE_BODY" >> $GITHUB_ENV; echo "$ISSUE_BODY" >> $GITHUB_ENV; echo "EOF_ISSUE_BODY" >> $GITHUB_ENV
          echo "Fetched issue details: Title='${ISSUE_TITLE:0:50}...'"
          echo "::endgroup::"

      - name: Fetch PR Diff
        id: format_pr_diff
        if: env.FINAL_CONTEXT_TYPE == 'pr'
        env:
          BASE_SHA: ${{ env.BASE_SHA }}
          HEAD_SHA: ${{ env.HEAD_SHA }}
        run: |
          echo "::group::Fetch PR Diff (like probe-base)"
          PR_DIFF="<!-- Diff generation failed or skipped -->"; RAW_DIFF_CONTENT=""
          if [[ -z "$BASE_SHA" || -z "$HEAD_SHA" || "$BASE_SHA" == "null" || "$HEAD_SHA" == "null" ]]; then
            echo "::warning::Cannot run git diff without valid base/head SHAs (Base: '$BASE_SHA', Head: '$HEAD_SHA')."
            RAW_DIFF_CONTENT="FETCH_FAILED"
          else
            echo "Fetching diff between $BASE_SHA...$HEAD_SHA"
            # Fetching the diff (like probe-base)
            set +e
            # Use patterns like probe-base if needed, simplified here
            git diff "${BASE_SHA}...${HEAD_SHA}" > raw_diff_output.txt 2> git_diff_stderr.log; GIT_DIFF_EXIT_CODE=$?; 
            set -e
            RAW_DIFF_CONTENT=$(cat raw_diff_output.txt)
            if [[ $GIT_DIFF_EXIT_CODE -ne 0 ]]; then echo "::warning::git diff exited with code $GIT_DIFF_EXIT_CODE."; if [[ -s git_diff_stderr.log ]]; then cat git_diff_stderr.log; fi; fi
            if [[ -z "$RAW_DIFF_CONTENT" && ( $GIT_DIFF_EXIT_CODE -eq 0 || $GIT_DIFF_EXIT_CODE -eq 1 ) ]]; then PR_DIFF="<!-- No relevant file changes found -->"; elif [[ -z "$RAW_DIFF_CONTENT" ]]; then RAW_DIFF_CONTENT="FETCH_FAILED"; fi
          fi

          # Apply filtering exactly like probe-base
          if [[ "$RAW_DIFF_CONTENT" != "FETCH_FAILED" && -n "$RAW_DIFF_CONTENT" ]]; then
              set +e; FILTERED_PR_DIFF_CONTENT=$(echo "$RAW_DIFF_CONTENT" | perl -ne 'BEGIN{$c="";$p=1;$l=500}if(/^diff --git a\/(.+?)\s+b\/(.+?)$/){print $c if $c ne ""&&$p;$c=$_;$p=1;$b=$2;if($b eq "/dev/null"||$b=~m/\.(lock|sum|mod|toml|cfg|ini|properties|yaml|yml|json|md|rst|adoc|txt|conf)$/i||$b=~m/(Makefile|Dockerfile|LICENSE|README)/i||$b=~m/\.(gitignore|dockerignore|.*rc)$/){$p=1}elsif(!-e $b){$p=1}else{if(open $fh,"<",$b){$r=0;while(<$fh>){$r++;chomp;if(length($_)>$l&&$_!~m{(https?://\S+|/\S+|[a-zA-Z0-9+/=]{20,}|d="M[\d\.,\sA-Za-z-]+}){$p=0;last}last if $r>=3}close $fh}else{$p=1}}}else{$c.=$_}END{print $c if $c ne ""&&$p}' 2> filter_stderr.log); PERL_PIPE_STATUS=${PIPESTATUS[1]}; set -e
              if [[ $PERL_PIPE_STATUS -ne 0 ]]; then echo "::warning::Perl filter exited: $PERL_PIPE_STATUS."; fi; if [[ -s filter_stderr.log ]]; then cat filter_stderr.log; fi
              if [[ -z "$FILTERED_PR_DIFF_CONTENT" && -n "$RAW_DIFF_CONTENT" ]]; then PR_DIFF="<!-- Diff filtered out -->"; elif [[ -n "$FILTERED_PR_DIFF_CONTENT" ]]; then PR_DIFF="$FILTERED_PR_DIFF_CONTENT"; fi
          elif [[ "$RAW_DIFF_CONTENT" == "FETCH_FAILED" ]]; then PR_DIFF="<!-- Error fetching diff -->"; fi

          # Simple XML escaping for CDATA (probe-base uses this structure)
          FILTERED_PR_DIFF_ESCAPED=$(echo "$PR_DIFF" | sed 's/]]>/]]\\&gt;/g')

          echo "PR_DIFF<<EOF_PR_DIFF" >> $GITHUB_ENV; echo "$FILTERED_PR_DIFF_ESCAPED" >> $GITHUB_ENV; echo "EOF_PR_DIFF" >> $GITHUB_ENV
          echo "Fetched and filtered diff (approx size: ${#FILTERED_PR_DIFF_ESCAPED} bytes)."
          echo "::endgroup::"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Aider and Dependencies
        run: |
          python -m pip install aider-install; aider-install
          pip install -U google-generativeai
          sudo apt-get update && sudo apt-get install -y jq

      - name: Determine Prompt for Aider
        id: determine_prompt
        shell: bash
        env: # Add all necessary env vars from previous steps in aider.yaml
          FINAL_CONTEXT_TYPE: ${{ env.FINAL_CONTEXT_TYPE }}
          ISSUE_OR_PR_NUMBER: ${{ env.ISSUE_OR_PR_NUMBER }}
          USER_REQUEST_BODY: ${{ env.USER_REQUEST_BODY }}
          STANDARD_COMMENTS_XML: ${{ env.STANDARD_COMMENTS_XML }}
          REVIEW_COMMENTS_XML: ${{ env.REVIEW_COMMENTS_XML }}
          PR_TITLE: ${{ env.PR_TITLE }}
          PR_BODY: ${{ env.PR_BODY }}
          PR_DIFF: ${{ env.PR_DIFF }}
          ISSUE_TITLE: ${{ env.ISSUE_TITLE }}
          ISSUE_BODY: ${{ env.ISSUE_BODY }}
          REQUEST_COMMENT_AUTHOR: ${{ env.REQUEST_COMMENT_AUTHOR }}
          REQUEST_COMMENT_TIMESTAMP: ${{ env.REQUEST_COMMENT_TIMESTAMP }}
          # No direct equivalent for these from probe-base, will rely on above for author/timestamp
          # DIRECT_USER_REQUEST_ENV: ${{ inputs.direct_user_request }}
          # MANUAL_INPUT_ENV: ${{ inputs.manual_input }}
          # TRIGGERING_ACTOR_ENV: ${{ github.triggering_actor }}
          # EVENT_NAME_ENV: ${{ github.event_name }}
          # EVENT_COMMENT_USER_LOGIN_ENV: ${{ github.event.comment.user.login }}
          # EVENT_COMMENT_CREATED_AT_ENV: ${{ github.event.comment.created_at }}
        run: |
          echo "::group::Assemble Final Prompt (mirroring probe-base.yml)"
          set -e
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION_TEXT=""
          PROMPT_FILE_PATH=".github/aider/aider-prompt-context.xml" # Changed filename for clarity
          mkdir -p .github/aider

          # Combine standard and review comments for PRs, similar to probe-base logic
          COMBINED_COMMENTS_XML="${STANDARD_COMMENTS_XML}"
          if [[ "$FINAL_CONTEXT_TYPE" == "pr" && -n "$REVIEW_COMMENTS_XML" ]]; then
            COMBINED_COMMENTS_XML="${STANDARD_COMMENTS_XML}${REVIEW_COMMENTS_XML}"
          fi

          if [[ "$FINAL_CONTEXT_TYPE" == "pr" ]]; then
              CONTEXT_DETAILS_XML="<details><title><![CDATA[$PR_TITLE]]></title><body><![CDATA[$PR_BODY]]></body></details>"
              # PR_DIFF from env already contains the fully processed (filtered and escaped) diff
              DIFF_XML="<diff><![CDATA[$PR_DIFF]]></diff>"
              PROMPT_INSTRUCTION_TEXT="You are Aider, an AI Pair Programmer. You are working on a GitHub Pull Request. Use the PR details, diff, and comments to understand the context. The user has provided a specific request in the <user_request> tag. Apply the requested changes to the specified files."
          elif [[ "$FINAL_CONTEXT_TYPE" == "issue" ]]; then
              CONTEXT_DETAILS_XML="<details><title><![CDATA[$ISSUE_TITLE]]></title><body><![CDATA[$ISSUE_BODY]]></body></details>"
              DIFF_XML="" # No diff for issues
              PROMPT_INSTRUCTION_TEXT="You are Aider, an AI Pair Programmer. You are working on a GitHub Issue. Use the issue details and comments to understand the context. The user (who triggered this workflow) has implicitly requested to fix this issue (details in <user_request>). Apply the necessary changes to the specified files."
          fi

          # USER_REQUEST_BODY, REQUEST_COMMENT_AUTHOR, REQUEST_COMMENT_TIMESTAMP are from initialize_context step
          # Escape USER_REQUEST_BODY for CDATA, it's raw from initialize_context
          USER_REQUEST_BODY_ESCAPED=$(printf "%s" "$USER_REQUEST_BODY" | sed 's/]]>/]]\\&gt;/g')

          FORMATTED_PROMPT="<github_context type=\"$FINAL_CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>${COMBINED_COMMENTS_XML}</comments>
            <user_request author=\"${REQUEST_COMMENT_AUTHOR}\" timestamp=\"${REQUEST_COMMENT_TIMESTAMP}\"><![CDATA[${USER_REQUEST_BODY_ESCAPED}]]></user_request>
            </github_context>
            <instructions><![CDATA[${PROMPT_INSTRUCTION_TEXT}]]></instructions>"

          if [ ${#FORMATTED_PROMPT} -lt 200 ]; then
            echo "::warning::Formatted prompt seems very short (${#FORMATTED_PROMPT} bytes)."
          fi
          echo "Final prompt assembled. Length: ${#FORMATTED_PROMPT} bytes."

          printf "%s" "$FORMATTED_PROMPT" > "$PROMPT_FILE_PATH"
          echo "Prompt written to $PROMPT_FILE_PATH"

          echo "PROMPT_FILE_PATH=$PROMPT_FILE_PATH" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"

      - name: Probe Chat for Relevant Files
        id: probe_files
        env:
          PROMPT_CONTENT_FILE: ${{ steps.determine_prompt.outputs.PROMPT_FILE_PATH }}
          # Pass key context for probe focus
          PR_TITLE: ${{ env.PR_TITLE }} # Available only on PR trigger
          LINKED_ISSUE_TITLE: ${{ steps.get_linked_issue.outputs.linked_issue_title }} # Available only on PR trigger if linked
          LINKED_ISSUE_NUMBER: ${{ steps.get_linked_issue.outputs.linked_issue_number }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          echo "Running probe-chat to find relevant files..."
          if [[ ! -f "$PROMPT_CONTENT_FILE" ]]; then
            echo "::error::Prompt file $PROMPT_CONTENT_FILE not found!"
            exit 1
          fi

          # Extract the core user request for probe-chat
          # For issues trigger, it's the whole file (or from API)
          # For PR comment trigger, extract from the structured prompt
          USER_REQUEST_FOR_PROBE=""
          if [[ "$EVENT_NAME" == "issues" ]]; then
              USER_REQUEST_FOR_PROBE=$(cat "$PROMPT_CONTENT_FILE")
          elif [[ "$EVENT_NAME" == "issue_comment" ]]; then
              # Attempt to extract content from <user_request> CDATA using basic tools
              USER_REQUEST_FOR_PROBE=$(sed -n 's/.*<user_request.*><!\[CDATA\[\(.*\)\]\]><\/user_request>.*/\1/p' "$PROMPT_CONTENT_FILE")
              if [[ -z "$USER_REQUEST_FOR_PROBE" ]]; then
                 echo "::warning::Could not extract user request from structured prompt for probe. Falling back to raw comment body."
                 # Fallback to raw comment body (might be less accurate)
                 RAW_COMMENT_BODY="${{ github.event.comment.body }}"
                 USER_REQUEST_FOR_PROBE="${RAW_COMMENT_BODY#*/aider}"
                 USER_REQUEST_FOR_PROBE="${USER_REQUEST_FOR_PROBE#"${USER_REQUEST_FOR_PROBE%%[![:space:]]*}"}"
                 USER_REQUEST_FOR_PROBE="${USER_REQUEST_FOR_PROBE%"${USER_REQUEST_FOR_PROBE##*[![:space:]]}"}"
              fi
          fi

          if [[ -z "$USER_REQUEST_FOR_PROBE" ]]; then
             echo "::error::Could not determine user request for probe!"
             exit 1
          fi

          # Prepare context for probe prompt
          CONTEXT_FOR_PROBE=""
          if [[ "$EVENT_NAME" == "issue_comment" ]]; then
             CONTEXT_FOR_PROBE="PR Title: $PR_TITLE\\n"
             if [[ -n "$LINKED_ISSUE_NUMBER" ]]; then
                CONTEXT_FOR_PROBE="${CONTEXT_FOR_PROBE}Linked Issue #$LINKED_ISSUE_NUMBER Title: $LINKED_ISSUE_TITLE\\n"
             fi
             CONTEXT_FOR_PROBE="${CONTEXT_FOR_PROBE}User Request: $USER_REQUEST_FOR_PROBE"
          else # Issues trigger
             CONTEXT_FOR_PROBE="Issue Context: $USER_REQUEST_FOR_PROBE" # User request here is the issue title/body/API result
          fi

          # Escape the context for JSON message
          MESSAGE_ESCAPED=$(jq -Rs . <<< "$CONTEXT_FOR_PROBE")

          # Construct the final message for probe-chat
          BASE_INSTRUCTION="Your job is ONLY to generate a list of files that need to be edited to implement the user's request."
          OUTPUT_INSTRUCTION="Output MUST be a single JSON array of file paths. Example: [\\\"src/main.rs\\\", \\\"lib/utils.ts\\\"]. DO NOT include explanations or any other text. Here is the user's request:"
          FINAL_MESSAGE_FOR_PROBE=$(printf "%s\\n%s\\nContext:\\n%s" "$BASE_INSTRUCTION" "$OUTPUT_INSTRUCTION" "$MESSAGE_ESCAPED")

          echo "Message being sent to probe-chat:"
          echo "$FINAL_MESSAGE_FOR_PROBE"

          set -o pipefail
          # Send the constructed message using --message argument
          PROBE_OUTPUT=$(npx --yes @buger/probe-chat@latest --model-name gemini-2.5-pro-preview-05-06 --message "$FINAL_MESSAGE_FOR_PROBE" 2>&1) || {
            echo "::error::probe-chat command failed. Output:"
            echo "$PROBE_OUTPUT"
            exit 1
          }
          set +o pipefail
          echo "Probe-chat raw output:"
          echo "$PROBE_OUTPUT"

          JSON_FILES=$(echo "$PROBE_OUTPUT" | sed -n '/^\s*\[/,$p' | sed '/^\s*\]/q')
          echo "Extracted JSON block:"
          echo "$JSON_FILES"

          FILES_LIST=$(echo "$JSON_FILES" | jq -e -r '[.[] | select(type == "string" and . != "" and . != null and (endswith("/") | not))] | map(@sh) | join(" ")' || echo "")

          if [[ -z "$FILES_LIST" ]]; then
             # Allow proceeding even if no files found, aider step will handle it
             echo "::warning::probe-chat did not identify any relevant files. Aider step might be skipped."
             FILES_LIST="" # Ensure it's empty
          fi

          echo "Formatted files list for aider: $FILES_LIST"
          echo "FILES_TO_EDIT=$FILES_LIST" >> $GITHUB_ENV

      - name: Run Aider with external prompt
        id: run_aider
        run: |
          echo "Files identified by probe-chat: ${{ env.FILES_TO_EDIT }}"
          # Check if FILES_TO_EDIT is empty (probe might have found none)
          if [[ -z "${{ env.FILES_TO_EDIT }}" ]]; then
            echo "::warning::Probe chat identified no relevant files. Skipping aider execution."
            echo "aider_output=Probe chat identified no relevant files to edit." >> $GITHUB_OUTPUT
            # Do not exit, let the workflow continue to report this
            exit 0
          fi

          # Aider will use the prompt file (.github/aider/issue-prompt.txt)
          # which now contains the full structured context for PR comments
          # or the API/issue context for issue triggers.
          aider \
            ${{ env.FILES_TO_EDIT }} \
            --model gemini/gemini-2.5-pro-preview-05-06 \
            --message-file .github/aider/issue-prompt.txt \
            --yes \
            --no-check-update \
            --auto-commits \
            --no-analytics \
            --no-stream | tee /tmp/aider_output.txt

          # AIDER_OUTPUT=$(cat /tmp/aider_output.txt) # Avoid intermediate variable
          echo "aider_output<<EOF" >> $GITHUB_OUTPUT
          cat /tmp/aider_output.txt >> $GITHUB_OUTPUT # Pipe directly
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Clean up prompt file
        if: always()
        run: rm -f .github/aider/issue-prompt.txt

      - name: Commit and Push Changes
        id: commit_and_push
        if: ${{ success() }}
        run: |
          if [[ "${{ github.event_name }}" == "issues" ]]; then
            BRANCH_NAME="aider-fix-issue-${{ github.event.issue.number }}"
            git checkout -b $BRANCH_NAME
            echo "Created branch $BRANCH_NAME for issue #${{ github.event.issue.number }}"
            git push origin $BRANCH_NAME
            echo "Pushed to new branch $BRANCH_NAME"
            echo "PR_BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "CHANGES_APPLIED_MESSAGE=Aider changes pushed to new branch $BRANCH_NAME." >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            CURRENT_BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
            echo "Attempting to push changes to PR branch $CURRENT_BRANCH_NAME for PR #${{ github.event.issue.number }}"
            if git push origin $CURRENT_BRANCH_NAME; then
              echo "Push to $CURRENT_BRANCH_NAME successful (or no new changes to push)."
              echo "CHANGES_APPLIED_MESSAGE=Aider changes (if any) pushed to PR branch $CURRENT_BRANCH_NAME." >> $GITHUB_OUTPUT
            else
              echo "::warning::Push to PR branch $CURRENT_BRANCH_NAME failed."
              echo "CHANGES_APPLIED_MESSAGE=Aider ran, but failed to push changes to PR branch $CURRENT_BRANCH_NAME." >> $GITHUB_OUTPUT
            fi
          fi

      - name: Create Pull Request
        if: success() && github.event_name == 'issues' && steps.commit_and_push.outputs.PR_BRANCH_NAME != '' && steps.commit_and_push.outputs.PR_BRANCH_NAME != null
        uses: peter-evans/create-pull-request@v6
        id: create_pr
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "[Aider PR] Add fixes for issue #${{ github.event.issue.number }}"
          branch: ${{ steps.commit_and_push.outputs.PR_BRANCH_NAME }}
          base: main
          delete-branch: true
          title: "[Aider] Fix for Issue #${{ github.event.issue.number }}: ${{ github.event.issue.title }}"
          body: |
            This PR was automatically generated by Aider based on issue #${{ github.event.issue.number }}.

            Linked to #${{ github.event.issue.number }}

            **Aider Output:**
            ```
            ${{ steps.run_aider.outputs.aider_output }}
            ```

      - name: Comment on issue
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          body: |
            ✅ Aider (via Gemini) has processed your request triggered by a `${{ github.event_name }}` event.

            ${{ steps.commit_and_push.outputs.CHANGES_APPLIED_MESSAGE || 'Aider processing complete.' }}

            ${{ github.event_name == 'issues' && steps.create_pr.outputs.pull-request-url && format('Pull Request created: {0}', steps.create_pr.outputs.pull-request-url) || '' }}${{ github.event_name == 'issues' && steps.commit_and_push.outputs.PR_BRANCH_NAME != '' && !steps.create_pr.outputs.pull-request-url && '*(PR creation may have been skipped or failed)*' || '' }}
            ${{ steps.run_aider.outputs.aider_output && steps.run_aider.outputs.aider_output != 'Probe chat identified no relevant files to edit.' && format('\\n**Aider Output:**\\n```\\n{0}\\n```', steps.run_aider.outputs.aider_output) || '' }}
