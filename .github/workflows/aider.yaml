name: Aider Auto-fix issues via external prompt

on:
  issues:
    types: [opened, edited]

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    env:
      # default model; can be overridden per-run if you like
      AIDER_MODEL: gemini
      GEMINI_API_KEY: ${{ secrets.GOOGLE_API_KEY }}

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install Aider
        run: python -m pip install aider-install; aider-install

      - name: Build prompt via external API
        shell: bash
        run: |
          # Use printf %q to safely quote title and body for shell evaluation
          ISSUE_TITLE_Q=$(printf '%q' "${{ github.event.issue.title }}")
          ISSUE_BODY_Q=$(printf '%q' "${{ github.event.issue.body }}")

          echo "Sending issue content to external API…"

          # Build JSON using jq --arg. Safely construct the command using the quoted variables.
          # We avoid direct eval by building the command parts.
          JSON_PAYLOAD=$(jq -n \
            --arg title "$ISSUE_TITLE_Q" \
            --arg body "$ISSUE_BODY_Q" \
            '{"body":{"issue_title":$title,"issue_body":$body}}')

          # Call your API
          # Use --data-binary to send the payload exactly as is
          API_RESULT=$(curl -s -w "\n%{http_code}" \
            -X POST "https://app.windmill.dev/api/r/test1245/issue-trigger" \
            -H "Content-Type: application/json" \
            --data-binary "$JSON_PAYLOAD" \
            --max-time 90)

          HTTP_CODE=$(echo "$API_RESULT" | tail -n1)
          BODY=$(echo "$API_RESULT" | sed '$d')

          # Save API response safely
          echo "$BODY" > /tmp/api_response.txt

          if [[ "$HTTP_CODE" -eq 200 ]]; then
            # Extract prompt safely with jq
            PROMPT=$(jq -r '.processed_prompt // .effective_body // .message // empty' /tmp/api_response.txt)
            if [[ -z "$PROMPT" ]]; then
              echo "::warning::API returned no prompt; falling back to raw issue."
              # Create fallback prompt safely using printf %s (quoting not needed for output)
              printf "Please fix the issue described below:\n\nTitle: %s\n\nBody:\n%s" \
                "${{ github.event.issue.title }}" \
                "${{ github.event.issue.body }}" > /tmp/prompt.txt
            else
              echo "$PROMPT" > /tmp/prompt.txt
            fi
          else
            echo "::error::API call failed (HTTP $HTTP_CODE). Falling back."
            # Create fallback prompt safely using printf %s
            printf "Please fix the issue described below:\n\nTitle: %s\n\nBody:\n%s" \
              "${{ github.event.issue.title }}" \
              "${{ github.event.issue.body }}" > /tmp/prompt.txt
          fi

          # write the final prompt
          mkdir -p .github/aider
          cat /tmp/prompt.txt > .github/aider/issue-prompt.txt

      - name: Run Aider with external prompt
        run: |
          AIDER_MODEL=gemini \
          aider \
            --model gemini-2.5-pro-preview-05-06 \
            --message-file .github/aider/issue-prompt.txt \
            --yes \
            --no-check-update \
            --auto-commits \
            --no-analytics \
            --stream=false

      - name: Commit & push fixes
        if: ${{ success() }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "[Aider] Apply fixes for issue #${{ github.event.issue.number }}" || echo "No changes to commit."
          git push

      - name: Comment on issue
        uses: peter-evans/create-or-update-comment@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          body: |
            ✅ Aider (via Gemini) has applied fixes based on the processed prompt.
