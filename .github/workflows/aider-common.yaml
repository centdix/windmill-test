name: Aider Common Steps

on:
  workflow_call:
    inputs:
      issue_title:
        description: "Title of the issue or PR"
        required: false
        type: string
      issue_body:
        description: "Body of the issue or PR"
        required: false
        type: string
      instruction:
        description: "Instruction for Aider"
        required: false
        type: string
      request:
        description: "Request for probe chat to find relevant files"
        required: false
        type: string
      prompt_file_path:
        description: "Path to the prompt file for Aider"
        required: false
        type: string
        default: ".github/aider/issue-prompt.txt"
      additional_aider_args:
        description: "Additional arguments for Aider"
        required: false
        type: string
        default: ""
    outputs:
      files_to_edit:
        description: "Files identified by probe-chat for editing"
        value: ${{ jobs.common-steps.outputs.files_to_edit }}
      prompt_file_path:
        description: "Path to the created prompt file"
        value: ${{ jobs.common-steps.outputs.prompt_file_path }}

jobs:
  common-steps:
    runs-on: ubicloud-standard-8
    outputs:
      files_to_edit: ${{ steps.probe_files.outputs.files_to_edit }}
      prompt_file_path: ${{ steps.create_prompt.outputs.prompt_file_path }}
    env:
      GEMINI_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      WINDMILL_TOKEN: ${{ secrets.WINDMILL_TOKEN }}

    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Aider and Dependencies
        run: |
          python -m pip install aider-install; aider-install
          pip install -U google-generativeai
          sudo apt-get update && sudo apt-get install -y jq

      - name: Create Prompt for Aider
        id: create_prompt
        if: inputs.issue_title != '' && inputs.issue_body != ''
        shell: bash
        env:
          WINDMILL_TOKEN: ${{ secrets.WINDMILL_TOKEN }}
        run: |
          PROMPT_FILE_PATH="${{ inputs.prompt_file_path }}"
          mkdir -p $(dirname "$PROMPT_FILE_PATH")

          ISSUE_TITLE="${{ inputs.issue_title }}"
          ISSUE_BODY=$(printf '%q' "${{ inputs.issue_body }}")
          INSTRUCTION="${{ inputs.instruction }}"

          echo "Processing issue with title: $ISSUE_TITLE"

          JSON_PAYLOAD=$(jq -n \
            --arg title "$ISSUE_TITLE" \
            --arg body "$ISSUE_BODY" \
            '{"body":{"issue_title":$title,"issue_body":$body}}')

          API_RESULT=$(curl -s -w "\n%{http_code}" \
            -X POST "https://app.windmill.dev/api/w/windmill-labs/jobs/run_wait_result/p/f/ai/quiet_script" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WINDMILL_TOKEN" \
            --data-binary "$JSON_PAYLOAD" \
            --max-time 90)

          HTTP_CODE=$(echo "$API_RESULT" | tail -n1)
          BODY=$(echo "$API_RESULT" | sed '$d')

          echo "$BODY" > /tmp/api_response.txt

          BASE_PROMPT="Try to fix the following issue based on the instruction given. The issue is prepended with the word ISSUE. The instruction is prepended with the word INSTRUCTION. The issue and instruction are separated by a blank line."
          if [[ "$HTTP_CODE" -eq 200 ]]; then
            PROCESSED_ISSUE_PROMPT=$(jq -r '.effective_body // empty' /tmp/api_response.txt)
            if [[ -z "$PROCESSED_ISSUE_PROMPT" || "$PROCESSED_ISSUE_PROMPT" == "null" ]]; then
              PROCESSED_ISSUE_PROMPT=""
            fi
            printf "%s\nISSUE:\n%s\nINSTRUCTION:\n%s" \
              "$BASE_PROMPT" "$PROCESSED_ISSUE_PROMPT" "$INSTRUCTION" > "$PROMPT_FILE_PATH"
          else
            echo "::warning::API call failed (HTTP $HTTP_CODE). Using raw issue content."
            printf "%s\nISSUE:\n%s\nINSTRUCTION:\n%s" \
              "$BASE_PROMPT" "$ISSUE_BODY" "$INSTRUCTION" > "$PROMPT_FILE_PATH"
          fi
          rm -f /tmp/api_response.txt

          echo "Prompt created and written to $PROMPT_FILE_PATH"
          echo "prompt_file_path=$PROMPT_FILE_PATH" >> $GITHUB_OUTPUT

      - name: Probe Chat for Relevant Files
        id: probe_files
        shell: bash
        env:
          PROMPT_CONTENT_FILE: ${{ inputs.prompt_file_path }}
          REQUEST: ${{ inputs.request }}
        run: |
          echo "Running probe-chat to find relevant files..."

          if [[ -n "$REQUEST" ]]; then
            PROMPT_CONTENT="$REQUEST"
          elif [[ -f "$PROMPT_CONTENT_FILE" ]]; then
            PROMPT_CONTENT=$(cat "$PROMPT_CONTENT_FILE")
          else
            echo "::error::Neither request nor prompt file provided!"
            exit 1
          fi

          if [ -z "$PROMPT_CONTENT" ]; then
             echo "::error::Prompt/request content is empty!"
             exit 1
          fi

          PROMPT_ESCAPED=$(jq -Rs . <<< "$PROMPT_CONTENT")

          MESSAGE_FOR_PROBE=$(jq -n --arg prompt_escaped "$PROMPT_ESCAPED" \
            '{ "message": "I'\''m giving you a request that needs to be implemented. Your role is ONLY to give me the files that are relevant to the request and nothing else. The request is prepended with the word REQUEST.\\nREQUEST: \($prompt_escaped). Give me all the files relevant to this request. Your output MUST be a single json array that can be parsed with programatic json parsing, with the relevant files. Files can be rust or typescript or javascript files. DO NOT INCLUDE ANY OTHER TEXT IN YOUR OUTPUT. ONLY THE JSON ARRAY. Example of output: [\"file1.py\", \"file2.py\"]" }' | jq -r .message)

          set -o pipefail
          PROBE_OUTPUT=$(npx --yes @buger/probe-chat@latest --max-iterations 50 --model-name gemini-2.5-pro-preview-05-06 --message "$MESSAGE_FOR_PROBE") || {
            echo "::error::probe-chat command failed. Output:"
            echo "$PROBE_OUTPUT"
            exit 1
          }
          set +o pipefail
          echo "Probe-chat raw output:"
          echo "$PROBE_OUTPUT"

          JSON_FILES=$(echo "$PROBE_OUTPUT" | sed -n '/^\s*\[/,$p' | sed '/^\s*\]/q')
          echo "Extracted JSON block:"
          echo "$JSON_FILES"

          FILES_LIST=$(echo "$JSON_FILES" | jq -e -r '[.[] | select(type == "string" and . != "" and . != null and (endswith("/") | not))] | map(@sh) | join(" ")' || echo "")

          if [[ -z "$FILES_LIST" ]]; then
             echo "::warning::probe-chat did not identify any relevant files."
          fi

          echo "Formatted files list for aider: $FILES_LIST"
          echo "files_to_edit=$FILES_LIST" >> $GITHUB_OUTPUT

      - name: Run Aider
        id: run_aider
        shell: bash
        env:
          FILES_TO_EDIT: ${{ steps.probe_files.outputs.files_to_edit }}
          MESSAGE_FILE: ${{ inputs.prompt_file_path }}
          ADDITIONAL_ARGS: ${{ inputs.additional_aider_args }}
        run: |
          echo "Files identified by probe-chat: $FILES_TO_EDIT"

          if [[ ! -f "$MESSAGE_FILE" ]]; then
            echo "::error::Message file $MESSAGE_FILE not found!"
            exit 1
          fi

          mkdir -p .github/aider

          aider \
            --read .cursor/rules/rust-best-practices.mdc \
            --read .cursor/rules/svelte5-best-practices.mdc \
            --read .cursor/rules/windmill-overview.mdc \
            $FILES_TO_EDIT \
            --model gemini/gemini-2.5-pro-preview-05-06 \
            --message-file $MESSAGE_FILE \
            --yes \
            --no-check-update \
            --auto-commits \
            --no-analytics \
            --no-gitignore \
            $ADDITIONAL_ARGS \
            | tee .github/aider/aider-output.txt || true
            
          echo "Aider command completed. Output saved to .github/aider/aider-output.txt"

      - name: Clean up prompt file
        if: always() && inputs.issue_title != '' && inputs.issue_body != ''
        run: rm -f ${{ inputs.prompt_file_path }}
